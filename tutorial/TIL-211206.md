# 1. 왜 데이터 페치 작업은 비동기 함수로 처리되어야 하는가? 
## 비동기 작업의 필요성
### 자바스크립트 실행 방식:
- 자바스크립트는 **싱글 스레드 언어**로, 한 번에 하나의 작업만 처리
- 네트워크 요청이나 파일 읽기 같은 작업은 시간이 오래 걸릴 수 있다.
- 이러한 작업을 동기작업으로 처리하면 자바스크립트가 해당 작업이 완료될 때까지 멈춰있어 **UI가 멈추고 애플리케이션이 응답하지 않게 된다**
### 비동기의 역할:
- 비동기 작업은 **백그라운드에서 실행**되고 완료 시점에 결과를 처리한다.
- 이를 통해 UI가 중단되지 않고 **원할하게 작동**할 수 있다.
---
# 2. `useEffect` 내에서 비동기 작업을 수행하려면 왜 비동기 함수를 정의하고 호출해야 하는가?
## **`useEffect`는 비동기 함수가 될 수 없다.**
### React의 규칙:
- `useEffect`는 기본적으로 동기 함수로 작동해야 한다.
- 이유는 React가 **렌더링 중 실행되는 모든 작업을 예측 가능**하게 유지하기 위해서이다.
- `useEffect`가 비동기 함수라면, 내부적으로 `await` 가 포함되면서 반환값이 `Promise`가 되기 때문에 React의 `useEffect` 규칙에 어긋난다.
### 비동기 작업을 수행하는 방법
- 해결책:
    - `useEffect` 내부에서 비동기 작업을 수행하려면 비동기 함수를 정의하고 이를 즉시 호출해야 한다.
    - 이렇게 하면 `useEffect`는 동기적으로 작동하면서도 비동기 작업으르 내부적으로 처리할 수 있다.
```javascript
useEffect(() => {
    const fetchData = async () => {
        const response = await fetch("https://api.example.com/data");
        setData(await response.json());
    };
    fetchData(); // 비동기 함수 호출
}, []);
```
---
# 마운트(Mount)란 무엇인가?
## 마운트의 정의
- 마운트(Mount)는 React 컴포넌트가 **DOM에 삽입되는 과정**을 의미
    - 컴포넌트가 처음 생성되고 브라우저에 렌더링될 떄 "마운트된다"고 표현
    - 예: `<div>`태그가 실제로 DOM 트리에 추가되는 시점.
## React의 컴포넌트 생명주기
## 1. 마운트 (Mount):
- 컴포넌트가 처음 화면에 나타날 때 실행.
- `useEffect`의 초기 실행은 이 시점에 동작.
## 2. 업데이트 (Update):
- 컴포넌트가 상태 변화(`setState`)나 프롭스(`props`) 변경으로 인해 다시 렌더링될 때 실행.
## 3. 언마운트(Unmount):
- 컴포넌트가 DOM에서 제거될 때 실행.
---
# 왜 데이터 패치 작업은 초기 렌더링 시 한 번만 실행되는가?
## 데이터 패치의 특징
- 데이터 페치(Network 요청)은 리소스를 많이 소모할 수 있는 작업
- 얘를 들어, 매번 렌더링할 때마다 데이터를 요청하면 불필요한 네트워크 요청이 발생
## 초기 렌더링에만 한 번 수행하는 이유
- 데이터 패치 작업은 보통 **초기 로드 데이터**를 가져오는 경우가 많다.
- 초기에 한 번 데이터를 가져오면 이후에 상태(`state`)를 통해 데이터를 관리할 수 있다.

`useEffect`와 빈 의존성 배열의 역할
```javascript
useEffect(() => {
    const fetchData = async() => {
        const response = await fetch("https://api.example.com/data");
        setData(await response.json());
    };
    fetchData();
}, []);
```
- 빈 배열(`[]`)을 의존성으로 전달하면 `useEffect`는 컴포넌트가 **처음 마운트될 때 단 한 번만 실행**된다.
- 이를 통해 **불필요한 네트워크 요청을 방지**하고 리소스를 절약할 수 있다.
---
# 요약
## 1. **데이터 패치 작업이 비동기적으로 처리되어야 하는 이유:**
- 동기 작업은 UI를 멈추게 만들 수 있지만, 비동기 작업은 UI를 방해하지 않고 백그라운드에서 처리한다.
## 2. **`useEffect` 내에서 비동기 작업을 처리하는 방식:**
- `useEffect`는 동기 함수로 작동해야 하므로, 내부에서 비동기 함수를 정의하고 바로 호출한다.
## 3. **마운트란**:
- React 컴포넌트가 DOM에 삽입되는 시점으로, 초기 렌더링 시점과 동의어로 볼 수 있다.
## 4. 데이터 페치 작업은 초기 렌더링에만 수행하는 이유:
- 네트워크 요청은 리소스를 많이 사용하므로, 초기 데이터를 한 번 가져오고 이후 상태를통해 관리하는 것이 효율적이다.
---
## `useParams`란?
- `useParams`는 **React Router**에서 제공하는 훅(hook)로, URL의 경로 파라미터(route parameter)에 접근할 수 있게 해준다. 
- 예를 들어, URL에 포함된 특정 값(예: `Id` 또는 `username`)을 컴포넌트에서 사용하고자 할 때 사용한다.
---
## `useParams`의 주요특징
### 1. URL 경로에서 동적 파라미터를 추출
- 라우트 경로에 설정된 **동적 세그먼트**(예: `:Id`)를 기반으로 해당 값을 반환
- `/user/:userId`: `:userId`는 동적 파라미터로 설정됨
## 2. 반환값:
- `useParams`는 **객체**를 반환하며, 경로에서 정의된 동적 세크먼트의 이름을 키(key)로, 실제 URL에서 해당 세그먼트에 대응하는 값을 값(value)으로 반환한다.
- `userParams`를 호출하면 `{ userId: '123' }` 객체를 반환한다.
## 3. 유용성:
- 주로 **디테일 페이지**(예: 게시물 상세보기, 사용자 프로필)에서 특정 ID나 이름을 가져와 데이터를 렌더링하는 데 사용된다.

## 자주 묻는 질문
### 1.`useParams`는 언제 사용해야 하나요?
- URL에서 동적 값을 추출해야 할 때 사용한다
- 주로 RESTful API 설계에 URL의 일부를 식별자로 사용하는 경우(예: `/user/:userId`, `/post/:postId`)가 유용하다.
### 2. URL에 동적 파미터가 없다면?
- 동적 세그먼트가 없는 URL에서 `useParams`를 호출하면 **빈 객체(`{}`)**를 반환한다.
### 3. `useParams`를 사용하지 않고 동적 파라미터를 얻을 수 있나요?
- 가능하지만 비효율적
    - `window.location.pathname`를 사용해 URL을 직접 파싱할 수 있지만, 코드가 복잡하고 React Router의 장점을 활용하지 못한다.
### 4. `useParams`로 여러 파라미터를 처리할 수 있나요?
- 가능. 경로에 여러 동적 세그먼트를 정의하면 각각의 값을 키-값 쌍으로 반환한다
```jsx
<Route path="/user/:userId/post/:postId" element={<UserPost />}>
```
- `useParams` 반환값:
```javascript
{ userId: '123', postId: '456' }
```
